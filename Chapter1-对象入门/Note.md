#对象入门
##1.3实现方案的隐藏
Java中有三个显式的关键字和一个隐式的关键字设置类的边界，其对应的访问范围如下表所示：

|      | 类内部 | 本包 | 子类| 外部包|
| -----|:----:|:----:|:----:| ----:| 
| public| √ | √ | √ | √ |
| protected| √ | √ | √ | × |
| default| √ | √ | × | × |
| private| √ | × | × | × |

##1.6多行对象的互换使用
把衍生类当做基类处理的行为叫做“上溯造型”（upcasting）
###1.6.1动态绑定
将一条消息发给对象时，如果并不知道对方的具体类型是什么，但采取的行动同样是正确的，这种情况就叫做“多形性”（Polymorphism），OOP中用于实现多形性的方法是动态绑定。

有些语言需要一些特殊的关键字修饰才能使用动态绑定，比如C++中的virtual，而Java中不需要任何关键字，因为函数的动态绑定自动进行。

###1.6.2抽象的基础类和接口
Java中使用abstract关键字修饰抽象类，抽象类无法创建对象。

abstract也可以修饰方法，抽象方法只能在抽象类中实现，而且继承的类必须实现该方法，否则该类也会变成一个抽象类。

Interface可以理解为一种更加严格的抽象类，它完全禁止了任何的函数实现。

##1.7对象的创建和存在时间
###1.7.2单根结构
Java中所有的类都来自于一个基本类――Object。
###1.7.3集合库与方便使用集合
向集合中添加一个句柄的时候，其会被上溯为一个Object，再次取用的时候得到的是一个Object，需要将它还原为原来的类型，还原的过程叫做下溯造型。

为了保证下溯造型的正确性，C++中使用了template关键字来实现参数化类型，但是Java尚未有参数化类型的实现，不过Java把generic设为了保留字。
##1.8违例控制：解决错误
Java中的违例控制模块是从一开始就封装好的，所以必须使用它。
违例控制并不是面向对象的特征（尽管面向对象语言中违例通常是使用一个对象表现的），早在面向对象问世之前违例控制就已经存在了。
##1.9多线程
Java的多线程机制已经内建到语言中。
Java的多线程支持是在对象这一级别的，所以一个执行线程可表达为一个对象。
Java也提供了有限的资源锁定方案，它能够锁定任何对象占用的内存，所以同一时间只能有一个线程使用特定的内存空间。
为达到这个目的需要使用synchronized关键字。其他类型的资源必须由程序员明确锁定，这通常要求程序员创建一个对象，用它代表一把锁，所有线程在访问那个资源时都必须检查这把锁。
##1.10永久性
Java1.1提供了对“有限永久性”的支持，这意味着我们可以将对象简单地保存到磁盘上，以后任何时间都可以取回。之所以称之为“有限”的，是由于我们仍然需要明确发出调用，进行对象的保存和取回工作。这些工作不能自动进行。