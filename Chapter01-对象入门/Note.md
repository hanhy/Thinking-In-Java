#第一章 对象入门

##1.3实现方案的隐藏

​	Java中有三个显式的关键字和一个隐式的关键字设置类的边界，其对应的访问范围如下表所示：

|           | 类内部  |  本包  |  子类  |  外部包 |
| --------- | :--: | :--: | :--: | ---: |
| public    |  √   |  √   |  √   |    √ |
| protected |  √   |  √   |  √   |    × |
| default   |  √   |  √   |  ×   |    × |
| private   |  √   |  ×   |  ×   |    × |

##1.6多行对象的互换使用

​	把衍生类当做基类处理的行为叫做“上溯造型”（upcasting）
###1.6.1动态绑定

​	将一条消息发给对象时，如果并不知道对方的具体类型是什么，但采取的行动同样是正确的，这种情况就叫做“多形性”（Polymorphism），OOP中用于实现多形性的方法是动态绑定。

​	有些语言需要一些特殊的关键字修饰才能使用动态绑定，比如C++中的virtual，而Java中不需要任何关键字，因为函数的动态绑定自动进行。

​	Java虚拟机调用一个类方法时，它会基于对象的引用类型（通常在编译时可知）来选择调用的方法；当jvm调用一个实例方法时，它会基于对象的实际类型（只能在运行时得知）来选择调用的方法。这就是动态绑定。

​	Java中以final、static、private修饰的方法和构造方法以及类的属性采用的是静态绑定。

​	private方法不能被继承，所以只能采用静态绑定。

​	final方法可以被继承，但是不能被覆盖，也是静态绑定。

​	构造方法也是不能被继承的。

​	static方法可以被继承，但是不能被覆盖，可以被隐藏。如果父类中有一个static方法，子类中没有定义这个方法，那么直接调用父类中的方法。如果有定义，那么将调用子类中的方法，但是当子类被上转型（上溯造型）为父类对象之后，无论自身有没有定义这个方法，都会调用父类的方法。因此说静态方法可以被隐藏但是不能被覆盖（这与属性是相同的），隐藏与覆盖的区别是，当子类对象被转型为父类对象的时候，可以访问父类被隐藏的变量和方法，但是不能访问父类被覆盖的方法。下面是一个static绑定的示例：

```java
public class Test extends Father {
	static void testStatic() {
		System.out.println("Child");
	}
	void testNormal() {
		System.out.println("Child");
	}
	public static void main(String[] args){
		Father f = new Test();
		f.testStatic();
		f.testNormal();
		
		Test t = new Test();
		t.testStatic();
		t.testNormal();
	}
}
class Father {
	static void testStatic() {
		System.out.println("Father");
	}
	void testNormal() {
		System.out.println("Father");
	}
}
```

​	该程序的输出为：

```java
Father
Child
Child
Child
```



###1.6.2抽象的基础类和接口

​	Java中使用abstract关键字修饰抽象类，**抽象类无法创建对象**。

​	abstract也可以修饰方法，抽象方法只能在抽象类中实现，而且继承的类必须实现该方法，否则该类也会变成一个抽象类。抽象类中的普通方法默认被子类继承，可以有实现，也可以没有实现。

​	Interface可以理解为一种更加严格的抽象类，它完全禁止了任何的函数实现。

##1.7对象的创建和存在时间

###1.7.2单根结构

​	Java中所有的类都来自于一个基本类——Object。
###1.7.3集合库与方便使用集合

​	向集合中添加一个句柄的时候，其会被上溯为一个Object，再次取用的时候得到的是一个Object，需要将它还原为原来的类型，还原的过程叫做下溯造型。

​	为了保证下溯造型的正确性，C++中使用了template关键字来实现参数化类型，但是Java尚未有参数化类型的实现，不过Java把generic设为了保留字。
##1.8违例控制：解决错误

​	Java中的违例控制模块是从一开始就封装好的，所以必须使用它。
违例控制并不是面向对象的特征（尽管面向对象语言中违例通常是使用一个对象表现的），早在面向对象问世之前违例控制就已经存在了。
##1.9多线程

​	Java的多线程机制已经内建到语言中。
​	Java的多线程支持是在对象这一级别的，所以一个执行线程可表达为一个对象。
​	Java也提供了有限的资源锁定方案，它能够锁定任何对象占用的内存，所以同一时间只能有一个线程使用特定的内存空间。
​	为达到这个目的需要使用synchronized关键字。其他类型的资源必须由程序员明确锁定，这通常要求程序员创建一个对象，用它代表一把锁，所有线程在访问那个资源时都必须检查这把锁。
##1.10永久性

​	Java1.1提供了对“有限永久性”的支持，这意味着我们可以将对象简单地保存到磁盘上，以后任何时间都可以取回。之所以称之为“有限”的，是由于我们仍然需要明确发出调用，进行对象的保存和取回工作。这些工作不能自动进行。
##1.12 分析和设计

###1.12.1 不要迷失

###1.12.2 阶段0：拟出一个计划

###1.12.3 阶段1：要制作什么

​	应该尽可能地总结出自己系统的一套完整的“使用条件”或“应用场合”。
​	不要过分在意系统规格的“完美”，否则也容易产生挫败感和焦躁情绪。
​	尽管仍处在初级阶段，但这时的一些日程安排也会非常管用。
​	最好依赖自己的经验和直觉（直觉也要建立在经验之上）计算出准确的日程安排。感觉一下需要花多长时间，然后将**这个时间加倍，再加上10%**。你的感觉可能是正确的；“也许”能在那个时间里完成。但**“加倍”使那个时间更加充裕，“10%”的时间则用于进行最后的推敲和深化**。但同时也要对此向上级主管做出适当的解释，无论对方有什么抱怨和修改，只要明确地告诉他们：这样的一个日程安排，只是我的一个估计！
###1.12.4 阶段2：如何构建

​	这一阶段必须拿出一套设计方案，并解释其中包含的各类对象在外观上是什么样子，以及相互间是如何沟通的。
​	此时可以考虑使用“统一建模语言”（UML）。
###1.12.5 阶段3：开始创建

​	无论计划多简单，如果能够掌握正确的设计结构，接下来的工作都会比一开始就埋头苦干好得多。
​	让代码做到我们想做的事，这是所有程序项目最终的目标，但是切不可急功冒进，否则只有得不偿失。
​	应当先拿出一份较为全面的方案，使其尽可能设想周全，能满足尽可能多的要求。
​	所有付出最终都会得到回报。作为程序员，这并非是一种可有可无的素质。全面的思考、周密的准备、良好的构造不仅使程序更易构建与调试。也使其更易理解和维护，而那正是一套软件盈利的必要条件。
​	构建好系统，并令其运行起来之后，必须进行实际检验，以前做的那些需求分析和系统规格便可以派上用场了。全面考察自己的程序，确定提出的所有要求均已满足。
###1.12.6 阶段4：校订

​	有时只有实际看到系统，才能意识到自己需要解决一个不同的问题。若认为这种形式的校订必然会发生，那么最好尽快拿出自己的第一个版本，检查它是否自己希望的，使自己的思想不断趋向成熟。
###1.12.7 计划的回报

​	根据估计，没有计划的50%以上的项目都会失败！
##1.13 Java还是C++

​	对计算机来说，最重要的是速度。现阶段，Java与C++的速度相差依然悬殊，况且C++拥有大量的爱好者，这些都表明C++短期之内不会被Java取代。