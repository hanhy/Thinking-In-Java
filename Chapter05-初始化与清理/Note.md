# 第五章 初始化与清理

## 5.1 用构造器确保初始化

​	创建对象时，如果其类具有构造器，Java就会在用户有能力操作对象之前自动调用相应的构造器，从而保证初始化的进行。

​	使用new关键字创建对象时，将会为对象分配存储空间，并调用相应的构造器，确保在操作之前就被合适地初始化了。

​	“每个方法的首字母必须小写”的编码风格不适用于构造器。

​	不接受任何参数的构造器叫默认构造器。

​	如果一个类没有默认构造器，比如，若Tree(int)是Tree类的唯一构造器，则编译器将不允许你使用任何其他方式构造Tree的对象。

​	Java中“初始化”和“创建”是捆绑在一起的，两者不能分离。

​	构造器是一种特殊类型的方法，因为它没有返回值，这与返回值为空（void）明显不同。

## 5.2 方法重载

​	在Java（和C++）中，构造器是强制重载方法名的一个原因，它允许用户用多种形式创建对象。

 ### 5.2.1 区分重载方法

​	每个重载的方法都必须有一个独一无二的参数类型列表。

​	方法名和参数列表唯一确定了一个类中的一个方法。

### 5.2.2 涉及基本类型的重载

​	如果传入的实际参数小于参数所声明的类型，则会被提升至对应的类型。char类型至少会提升至int类型。相反的，如果传入参数的大于所声明的类型，必须显式地进行类型转换，否则编译器会报错。

​	基本类型的大小顺序如下所示：```char<byte<short<int<long<float<double```

### 5.2.3 以返回值区分重载方法

​	再不需要返回值调用的时候，是区分不出的，如```f();```

## 5.3 默认构造器

​	如果没有构造器，则编译器会自动创建一个无参构造器，为了保证能够创建对象。如果已经有构造器，且全都是有参数的构造器，那么再使用无参构造器会报错。

## 5.4 this关键字

​	对象的方法其实都有一个默认的参数，编译器自动将参数本身传递给这个方法。如果想要显式的使用这个对象本身，就需要使用this关键字。**仅在必要的时候使用this关键字**。

### 5.4.1 在构造器中调用构造器

​	可以使用this关键字在构造器中调用其他的构造器，调用形式是```this(Type args);```。但是只能放在程序的最开始。

​	不能在一个构造器中重复调用构造器，仅能使用一次这种写法。

​	除了构造器之外，类的其他方法不允许使用构造器。

​	this的另外一种使用场景是写在类的setter中。

### 5.4.2 static的含义

​	static方法中不能调用非静态方法，反过来可以。某个角度来说，static方法就是没有this关键字的方法。static没有那么“面向对象”，但是这正是它最主要的使用方式。

## 5.5 清理：终结处理和垃圾回收

1. 对象可能不被垃圾回收
2. 垃圾回收并不等于“析构”

### 5.5.1 finalize()的用途何在

3. 垃圾回收只与内存有关

### 5.5.2 你必须实施清理

​	java不允许创建局部对象，必须使用**new**创建对象。无论是垃圾回收还是finalize，都不保证一定会发生，，如果Jvm没有面临内存快要耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存的。

### 5.5.3 终结条件

​	设置一个终结条件放在finalize中进行判断，是一种常用的方法。

### 5.5.4 垃圾回收器如何工作

​	Java在堆上分配对象。

​	堆指针、标记－清扫、停止复制。

## 5.6 成员初始化

​	Java中，方法的局部变量如果没有显示地初始化，会编译错误。而如果是类中的变量，则会被适当地初始化。基本类型有其初始化的默认值，对象的引用则会被初始化为null。

### 5.6.1 指定初始化

​	为某个变量赋初值，可以在声明的时候就写进一个默认值。甚至可以通过调用方法来提供初值，方法可以是有参数的，但是传入的参数必须是被初始化了的。

## 5.7 构造器初始化

​	可以在构造器中进行初始化，但是类的成员会在构造器执行前就被初始化。

### 5.7.1 初始化顺序

​	变量定义的先后顺序决定了初始化的顺序，即使变量定义散布到方法定义之间，变量的初始化也会在任何方法被调用之前被初始化。

### 5.7.2 静态数据的初始化

​	先进行静态对象进行初始化（如果之前该静态对象已经由之前的创建过程被初始化过了，则不再进行初始化），再对非静态对象进行初始化。

​	现将对象的初始化过程总结如下（以Dog类为示例）：

1. 即使没有显示地使用static关键字，但是构造器实际上也是静态方法（可看作），因此首次创建Dog对象的时候，或者Dog的静态域或静态方法被访问的时候，Java解释器必须查找类的路径，定位Dog.class文件。
2. 载入Dog.class，执行所有的静态初始化，该过程仅发生一次
3. 创建new Dog()，在堆上为Dog对象分配空间
4. 存储空间清零，对应的域被合适地初始化
5. 执行字段定义之处的初始化操作
6. 执行构造器中的初始化操作

### 5.7.3 显式的静态初始化

​	多个静态初始化语句可以组成一个静态子句，写法如下：

```java
public class Spoon {
  static int i;
  static {
    i = 47;
  }
}
```

​	这类初始化子句在进行类的初始化的时候优先级与普通的静态变量相同。

### 5.7.4 非静态实例初始化

​	写法与静态子句相同，只是少了static关键字，其执行优先级与普通的非静态变量相同。

## 5.8 数组初始化

​	数组进行定义的时候不允许指定数组的大小。length属性可以展示数组的长度。有几种初始化数组的方式。

```java
int[] a = {1, 2, 3, 4, 5};

Interger[] a = {
  new Integer(1);
  new Integer(2);
  3,
}

Integer[] a = new Integer[]{
  new Integer(1),
  new Integer(2),
  3,
}
```

初始化之前，数组只是一个引用，没有为它分配任何空间，执行初始化之后，数据才会被正确地初始化。

### 5.8.1 可变参数列表

​	Java SE5之后新增了可变参数列表，写法为：

```java
func (Object... args) {
  
}
```

## 5.9 枚举类型

​	Java SE5之后添加了美剧类型，enum，其中有几个内置的方法可供使用。

​	toString()方法，可以方便地显示枚举的名字；

​	ordinal ()方法，可以显示枚举的声明顺序；

​	static values()方法，可以按照声明顺序来产生这些常量构成的数组。

​	enum可以很方便地与switch结合使用。

## 5.10 总结

