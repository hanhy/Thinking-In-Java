 # 第三章 操作符

## 3.1 更简单的打印语句

​	这一部分使用了mindview的代码，简化了打印语句。

​	**练习1**:使用“简短的”和正常的打印语句来编写一个程序。

## 3.2 使用Java操作符

​	几乎所有的操作符都只能操作基本类型，但是"="、"=="、"!="这三个操作符能操作所有的对象。

## 3.3 优先级

​	注意System.out.println();语句中多个参数使用"+"的时候，都是按加号的顺序判断加号后面的变量是不是和加号前面的变量同一类型。如果是直接相加，如果不是，若前面的变量是String类型，则，加号后面的数据也会被转化为String类型；如果前面不是String类型，则二者都会转化为String类型。

## 3.4 赋值

​	对于基本类型而言，赋值只是传值，而不会改变赋值者本身的数值。即使是被赋值者变化，赋值者的值也不会变。

​	对于对象类型而言，赋值者和被赋值者指向的是同一个对象，只不过二者是不同的引用。所以任何一个引用改变了对象的值，二者都会跟着改变。这种现象叫做“别名现象”。为消除别名现象，只能够不直接使用赋值符号，而是将两个对象的基本类型的域使用赋值符号连接。

​	**练习2**:创建一个包含一个float域的类，并用这个类来展示别名机制。

### 3.4.1 方法调用中的别名问题

​	一个方法使用传参的方法传进一个对象的引用，对其进行操作相当于对对象直接操作。

​	**练习3**:创建一个包含一个float域的类，并用这个类来展示方法调用时的别名机制。

## 3.5 算术操作符

​	Random类型产生的数字是伪随机数，创建对象时的参数就是随机数种子，如果没有参数，就以当前时间为参数。其生成随机数的方法很简单，只需要调用方法nextInt()等即可获得对应类型的随机数。

​	**练习4:**编写一个计算速度的程序，它所使用的距离和时间都是常量。

### 3.5.1 一元加、减操作符

​	一元减号可以用于转变数据的符号，而一元加号只是为了与一元减号相对应，但是它唯一的作用就是将较小类型的操作数提升为int。

## 3.6 自动递增和递减

​	前缀递增和前缀递减会先执行运算再生成值。

​	后缀递增和后缀递减会先生成值再执行运算。

## 3.7 关系操作符

### 3.7.1 测试对象的等价性

​	**练习5:**创建一个名为Dog的类，它包含两个String域：name和says。在main()方法中，创建两个Dog对象，一个名为spot（它的叫声为“Ruff！”），另一个名为scruffy（它的叫声为“Wurf！”）。然后显示它们的名字和叫声。

​	**练习6:**在练习5的基础上，创建一个新的Dog索引，并对其赋值为spot对象。测试用==和equals()方法来比较所有引用的结果。

## 3.8 逻辑操作符

​	如果在本应该使用String的地方使用了布尔值，布尔值会自动转换为适当的文本形式。

### 3.8.1 短路

## 3.9 直接常量

​	十六进制的前缀为0x或0X。八进制的前缀为0。可以使用Integer或Long的toBianryString()方法将数字（无论进制）使用二进制表示。

​	**练习8:**展示用十六进制和八进制计数法来操作long值，用Long.toBinaryString()来显示结果。

### 3.9.1  指数计数法

​	指数计数法中的e指的是10而不是自然对数的底e。这是由于早起的FORTRAN语言都是大写的，所以不会与小写的e产生冲突。

​	**练习9:**分别显示用float和double指数计数法所能表达的最大和最小的数字。

## 3.10 按位操作符

​	按位操作符（除一元操作符~之外）可以和=连用。

​	布尔类型作为一种特殊的单比特值，可以对其进行按位操作，但是不能执行按位非~操作。对于布尔值而言，按位操作符具有和逻辑操作符相同的效果，只是它们不会中途“短路”。

​	**练习10:**编写一个具有两个常量值的程序，一个具有交替的二进制位1和0，其中最低有效位为0，另一个也具有交替的二进制位1和0，但是其最低的有效位为1。取这两个值，用按位操作符以所有可能的方式结合运算它们，然后用Integer.toBianryString()显示。

## 3.11 移位操作符

​	移位操作符只可以用来处理整数类型，左移位操作符（<<）的操作数向左移位，低位补0；右移位操作符（>>）的操作数向右移位，高位使用符号扩展：负数补1，正数补0。

​	Java中增加了一种“无符号”右移位操作符（>>>），它使用“零扩展”，无论正负，高位都插入0。

​	char、byte、short等类型进行移位操作的时候会默认先转为int类型。得到的结果也是一个int类型的数值。此时右操作数只有低五位才有用，因为int只有32位，2的五次方是32。同理，对long类型进行移位操作的时候，右操作数只有低六位是有效的，得到的也是一个long类型的结果。

​	移位操作符可以和等号组合使用。

​	若对byte、short这样的类型进行右移位操作，得到的可能不是正确的结果，它们会先被转化为int型，进行右移操作，得到的结果再进行截断操作，此时有可能会得到-1的结果。

​	**练习11:**以一个最高有效位为的二进制数字开始，用有符号右移操作赋对其进行右移，直至所有的二进制位都被移出为止，毎移一位都要使用Integer.toBinaryString()显示结果。

​	**练习12:**以一个所有位都为1的二进制数字开始，先左移它，然后用无符号右移操作符对其进行右移，直至所有的二进制位都被移出为止，毎移一位都要使用Integer.toBinaryString()显示结果。

​	**练习13:**编写一个方法，它以二进制形式显示char类型的值。使用多个不同的字符来展示它。

## 3.12 三元操作符if-else

## 3.13 字符串操作符+和+=

​	操作符重载在Java中更易于实现，但是它终究太过于复杂，所以，Java不允许进行操作符的重载。

​	如果表达式以一个字符串起头，那么后续所有操作数都必须是字符串型。因此，一旦表达式前端使用了字符串操作符，后面将不允许使用任何基本操作类型（+会被当作字符串操作符），否则编译器将会报告错误。

## 3.14 使用操作符时常犯的错误

​	表达式

```java
x=y
```

​	的值等于y的值。

## 3.15 类型转换操作符

​	Java中的类型转换可能是多余的，比如必要的时候int值会被自动转为long类型，但是你仍然可以做这样的事，不会出现错误，可以以此来提醒自己注意。而有时只有先进行类型转换，代码编译才会通过。

​	如果要执行“窄化转换”的操作，就可能面临信息丢失的危险。此时必须进行显式地转换处理。

​	Java允许我们将任何类型的基本数据类型转化为另一种基本数据类型，布尔类型除外，布尔类型不允许任何形式的转换。

### 3.15.1 截尾和舍入

​	将float或者double类型的数据转换为整形时，总是对该数字执行截尾。如果想要得到舍入的结果，就需要使用java.lang.Math中的round()方法。此方法是java.lang的一部分，因此不需要额外的导入，下面是一个使用示例。

```java
System.out.println(Math.round(0.7f));
```

## 3.16 Java没有sizeof

​	sizeof是C中为了防止移植的时候出现的机器间分配位数大小的不同而设置的，而Java中所有的基本类型都是定义好了的，其跨平台特性也决定了无需进行系统间的size判断。

## 3.17 操作符小结

​	对于char、byte、short，复合赋值不需要进行类型转换，尽管有类型的提升，但是其结果和直接运算的结果相同，而且不使用类型转换也可以使代码更加简练。

​	除布尔类型之外，任何一种基本类型都可以通过类型转换变为其它类型。

​	**练习14:**编写一个接收两个字符串参数的方法，用各种布尔值的比较关系来比较这两个字符串，然后把结果打印出来。做==和!=比较的同时，用equals()做测试。在main()里面用几个不同的字符串对象调用这个方法。

## 3.18 总结

​	本章主要是操作符的基础知识，对于右一定经验的读者来说，需要注意的只是以前没有主意的细节。